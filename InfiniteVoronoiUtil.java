import java.awt.Color;

public class InfiniteVoronoiUtil {
    // Default grid cell size (in pixels) for seed placement.
    private static final int DEFAULT_CELL_SIZE = 100;
    
    /**
     * Returns a pseudo‑random hash for two integers.
     * This function works with negative values as well.
     *
     * @param x an integer value
     * @param y another integer value
     * @return a hashed integer
     */
    public static int hash(int x, int y) {
        int h = x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return h ^ (h >> 16);
    }
    
    /**
     * A private inner class representing a seed point.
     * Each seed has an (x, y) coordinate and an associated color.
     */
    private static class Seed {
        final double x, y;
        final Color color;
        
        Seed(double x, double y, Color color) {
            this.x = x;
            this.y = y;
            this.color = color;
        }
    }
    
    /**
     * Computes (deterministically) the seed for the grid cell at coordinates (i, j).
     * Each grid cell gets one seed whose precise position is jittered inside the cell,
     * and whose color is generated by mapping a hash value into HSB space.
     *
     * @param i        the grid cell's x-index
     * @param j        the grid cell's y-index
     * @param cellSize the size (in pixels) of each grid cell
     * @return the seed for that cell
     */
    public static Seed getSeedForCell(int i, int j, int cellSize) {
        // Compute a hash for the cell to determine a jitter offset.
        int hOffset = hash(i, j);
        // Use a different hash (with a slight variation) to compute a color.
        int hColor = hash(i + 1, j - 1);
        
        // Derive fractional offsets in the range [0,1) from the hash.
        float ox = (hOffset & 0xFF) / 255.0f;
        float oy = ((hOffset >> 8) & 0xFF) / 255.0f;
        
        // Map bits from hColor into HSB components.
        float hue = (hColor & 0xFF) / 255.0f;
        float saturation = 0.5f + (((hColor >> 8) & 0xFF) / 255.0f) * 0.5f;
        float brightness = 0.7f + (((hColor >> 16) & 0xFF) / 255.0f) * 0.3f;
        Color color = Color.getHSBColor(hue, saturation, brightness);
        
        // The absolute position of the seed is the cell's top-left plus the jitter offset.
        double seedX = (i + ox) * cellSize;
        double seedY = (j + oy) * cellSize;
        return new Seed(seedX, seedY, color);
    }
    
    /**
     * Returns the color at the given absolute coordinate (ax, ay) on the infinite Voronoi plane,
     * using the provided cellSize to determine seed spacing.
     * This method checks the 3×3 neighborhood of grid cells to find the nearest seed.
     *
     * @param ax       the absolute x-coordinate in the plane
     * @param ay       the absolute y-coordinate in the plane
     * @param cellSize the grid cell size used for seed placement
     * @return the Color computed for that point
     */
    public static Color getColorAt(double ax, double ay, int cellSize) {
        // Determine the grid cell that contains (ax, ay).
        int cellX = (int) Math.floor(ax / cellSize);
        int cellY = (int) Math.floor(ay / cellSize);
        
        double minDist2 = Double.MAX_VALUE;
        Color nearestColor = Color.BLACK;
        
        // Check the 3×3 neighborhood of cells, which is sufficient for jittered seeds.
        for (int i = cellX - 1; i <= cellX + 1; i++) {
            for (int j = cellY - 1; j <= cellY + 1; j++) {
                Seed seed = getSeedForCell(i, j, cellSize);
                double dx = ax - seed.x;
                double dy = ay - seed.y;
                double dist2 = dx * dx + dy * dy;
                if (dist2 < minDist2) {
                    minDist2 = dist2;
                    nearestColor = seed.color;
                }
            }
        }
        return nearestColor;
    }
    
    /**
     * Overloaded version of getColorAt that uses a default cell size.
     *
     * @param ax the absolute x-coordinate in the plane
     * @param ay the absolute y-coordinate in the plane
     * @return the Color computed for that point
     */
    public static Color getColorAt(double ax, double ay) {
        return getColorAt(ax, ay, DEFAULT_CELL_SIZE);
    }
    
    /**
     * Simple demonstration of getColorAt().
     * This main method prints out the computed colors for various coordinates.
     */
    public static void main(String[] args) {
        // Test coordinates (in the infinite plane)
        for (int y = 0; y < 5; y++) {
            for (int x = 0; x < 5; x++) {
                // Multiply coordinates by 50 for demonstration purposes.
                double ax = x * 50.0;
                double ay = y * 50.0;
                Color c = getColorAt(ax, ay);
                System.out.printf("Color at (%.1f, %.1f): #%02X%02X%02X%n", 
                                  ax, ay, c.getRed(), c.getGreen(), c.getBlue());
            }
        }
    }
}